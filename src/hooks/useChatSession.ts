import { useState, useEffect, useCallback } from 'react';
import type { ChatMessage, SessionSummary } from '../api';
import { 
  sendConsultoriaMessage, 
  fetchSessions, 
  fetchMessages, 
  deleteSession 
} from '../api';

interface User {
  id: string;
}

interface UseChatSessionProps {
  user: User | null;
  session?: { access_token: string } | null;
  language: string;
  toneLevel: number;
  t: (key: string) => string;
}

export type SessionState = {
  id: string | null;
  title: string;
  messages: ChatMessage[];
};

export function useChatSession({ user, session, language, toneLevel, t }: UseChatSessionProps) {
  const [sessions, setSessions] = useState<SessionSummary[]>([]);
  const [currentSession, setCurrentSession] = useState<SessionState>({
    id: null,
    title: t('chat.session.new'),
    messages: [],
  });
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingSessions, setIsLoadingSessions] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Load sessions on user change
  useEffect(() => {
    if (!user || !session?.access_token) return;
    
    const loadSessions = async () => {
      setIsLoadingSessions(true);
      try {
        const data = await fetchSessions(session.access_token);
        setSessions(data);
      } catch (err) {
        console.error('Failed to load sessions', err);
      } finally {
        setIsLoadingSessions(false);
      }
    };

    loadSessions();
  }, [user, session?.access_token]);

  const handleNewSession = useCallback(() => {
    setCurrentSession({
      id: null,
      title: t('chat.session.new'),
      messages: [],
    });
    setError(null);
  }, [t]);

  const handleSelectSession = useCallback(async (selectedSession: SessionSummary) => {
    if (!user || !session?.access_token) return;
    
    setIsLoading(true); // Reuse isLoading or add specific one
    try {
      const messages = await fetchMessages(session.access_token, selectedSession.id);
      setCurrentSession({
        id: selectedSession.id,
        title: selectedSession.title,
        messages,
      });
      setError(null);
    } catch (err) {
      console.error('Failed to load messages', err);
      setError('Erro ao carregar mensagens.');
    } finally {
      setIsLoading(false);
    }
  }, [user, session?.access_token]);

  const handleDeleteSession = useCallback(async (sessionId: string, event: React.MouseEvent) => {
    event.stopPropagation();
    if (!user || !session?.access_token) return;

    if (!window.confirm(t('chat.sidebar.confirmDelete'))) return;

    try {
      const success = await deleteSession(session.access_token, sessionId);
      if (success) {
        setSessions((prev) => prev.filter((s) => s.id !== sessionId));
        if (currentSession.id === sessionId) {
          handleNewSession();
        }
      }
    } catch (err) {
      console.error('Failed to delete session', err);
    }
  }, [user, session?.access_token, currentSession.id, handleNewSession, t]);

  const sendMessage = useCallback(async (text: string, focusToSend?: string | null) => {
    if (!user || !text.trim()) return;

    const now = new Date().toISOString();
    const userMessage: ChatMessage = {
      id: crypto.randomUUID(), // Temporary ID
      sender: 'user',
      text,
      createdAt: now,
    };

    // Optimistic update
    setCurrentSession((prev) => ({
      ...prev,
      messages: [...prev.messages, userMessage],
    }));
    
    setIsLoading(true);
    setError(null);

    try {
      const result = await sendConsultoriaMessage({
        userId: user.id,
        conversationId: currentSession.id,
        message: text,
        history: currentSession.messages,
        focus: focusToSend,
        language: language,
        toneLevel: toneLevel,
        token: session?.access_token,
      });

      const aiMessage: ChatMessage = {
        id: crypto.randomUUID(),
        sender: 'ai',
        text: result.reply,
        createdAt: new Date().toISOString(),
      };

      const conversationId = result.conversationId;
      
      setCurrentSession((prev) => {
        // If it was a new session, update ID
        if (prev.id !== conversationId) {
          return {
            ...prev,
            id: conversationId,
            messages: [...prev.messages, aiMessage]
          };
        }
        return {
          ...prev,
          messages: [...prev.messages, aiMessage]
        };
      });

      // Update session list if it was a new session
      if (!currentSession.id) {
        const title = text.length > 60 ? `${text.slice(0, 57)}...` : text;
        const newSummary: SessionSummary = {
          id: conversationId,
          title: title, // Backend generates title too, but we can approximate here or refetch
          createdAt: now,
        };
        
        // Optionally fetch sessions to get the exact title generated by backend
        // For now, let's just prepend to list locally
        setSessions((prev) => [newSummary, ...prev]);
        
        // Re-fetch sessions to ensure consistency (e.g. backend title generation)
        if (session?.access_token) {
           fetchSessions(session.access_token).then(setSessions);
        }
      }

    } catch (err: any) {
      console.error(err);
      let errorMessage = err.message || t('chat.body.error');
      if (errorMessage === 'Failed to fetch') {
        errorMessage = t('chat.body.fetchError');
      }
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [user, session, currentSession, language, toneLevel, t]);

  return {
    sessions,
    currentSession,
    isLoading,
    isLoadingSessions,
    error,
    handleNewSession,
    handleSelectSession,
    handleDeleteSession,
    sendMessage,
  };
}
